Cette biblio se fera tout au long de votre module, et comprendra de manière succincte:
     - 
##1 Explication du modèle OpenGL pour le fonctionnement du processeur graphique: quels sont les blocs fonctionnels du GPU et
     à quoi servent-ils
##2 Principes de base de OpenGL: Représentation des données et des transformations géometriques: Matrices, vertex, lignes/triangles/..., projection et modèle de caméra
##3 Principes de base de OpenGL: Texture et système de coordonnées
##4 Principes de base de OpenGL: Modèle de lumière            
##5 Principes de base de OpenGL: Expliquez les différences entre DisplayList, VeretxArray et VertexBufferObject

##1 OpenGL Rendering Pipeline and the GPU

TODO par Pierre Lorin de Reure

##2 Principes de base de OpenGL: Représentation des données et des transformations géometriques: 
	Matrices, vertex, lignes/triangles/..., projection et modèle de caméra

== Les données de base OpenGL	
Les objets que OpenGl et le GPU savent bien traiter s'appellent les primitives (points, lignes et polygones). 
Elles crées à partir de sommets, dont on donne coordonnées spatiales entre les instructions glBegin() et glEnd().
La plupart des surfaces sont construites à partir de triangles. Ainsi l'approximation de surfaces courbées se fait grâce à une décomposition en triangles, 
dont qualité est définie par la subdivision.

L'intérêt d'OpenGL est de représenter ces primitives dans un espace 3D, 
de naviguer dans cet espace 3D et de choisir un point d'observation.
On peut alors, à l'aide de transformations matricielles, projeter ce qu'on voit depuis ce point d'observation sur un écran 2D. 

== Les transformations (produits matriciels)
#La transformation viewport
Permet d'indiquer sur quelle partie de la fenêtre on va occuper
glViewPort() 

#La transformation de projection (définit l'espace qui sera rendu)

Projection Perspective :
Analogie : choisir la lentille de la caméra
Spécifier la transformation qui rend les objets plus petits quand il sont loin, et borner l'espace qui sera rendu
glFrustum(-x1,x1,-y1,y1, distance au plan1, distance au plan2) 

Projection Orthonormale :
Analogie : Observation à l'infini
glOrtho(-x,x,-y,y-,z,z)

#Les transformations Viewing 
Analogie : positioner et viser avec la caméra
Faire un reset des transformations (matrice identité :) glLoadIdentity()
Choisir la translation de la caméra glTranslate[fdl]() et la rotation associée
OU utiliser la routine glu : gluLookAt() : spécifier la position de la caméra, un pt de référence, et le "haut" de la caméra

#Les transformations Modeling
Analogie : placer les éléments sur la scène
Positioner, orienter et scaler le modèle utilisé
On utilise les matrices de transformations entre glBegin() et glEnd()
On utilisera le stack des matrices glMatrixPush et glMatrixPop 

Note : Si l'on considère un repère absolu, considérer les transformations en ordre inverse

##3 Principes de base de OpenGL: Texture et système de coordonnées

##4 Principes de base de OpenGL: Modèle de lumière
OpenGL raisonne sur des sources de lumières en RVB            
Division de l'éclairage en 4 : lumière  émissive, ambiante, diffuse, spéculaire

#Ambient illumination
Phénomène physique réel : réflection de la lumière sur les surfaces banales (murs, objects non réfléchissants, etc.)
Approximation OpenGL : impossible de déterminer l'origine des sources, donc on considère un niveau global de lumière dans l'espace
Elle est éparpillée dans toutes les directions

#Diffuse light
Phénomène physique réel : modèle facile utilisé par les télécom, réflection par les isolants
OpenGL : Lumière qui arrive d'une direction particulière, mais qui est réfléchie dans toutes les directions au contact d'un objet

#Specular light
Phénomène physique réel : exemple : effet de peau dans les métaux
OpenGL : Lumière qui arrive d'une direction particulière, et est renvoyée dans une autre direction particulière
C'est ce qu'on utilisera pour les points lumineux sur les objets

#Emissive color : 
Fonction de gain sur la lumière reçue et éclairement de base, sans augmenter la lumière renvoyée dans l'environnement.

#Affichage de la couleur
OpenGL gère l'absorption de fréquences via l'absorption de R, V et B de l'objet. La couleur affichée sera en taux de R,V, et B renvoyée par les objets.
Pour les flux lumineux/sources, (R,V,B) définissent l'intensité de la lumière (~quantité d'énergie, maximum = tous les pixels allumés, blanc)
Pour les objets, (R,V,B) définissent la partie réfléchie
Addition des couleurs renvoyées par chaque objet

#Rendering light :
Définir les vecteur normaux pour chaque surface (vers l'extérieur !)
Définir des sources
Choisir un modèle de lumière (lumière ambiante, etc.)
Définir les propriétés des matériaux

