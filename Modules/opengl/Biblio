Cette biblio se fera tout au long de votre module, et comprendra de manière succincte:
     - 
##1 Explication du modèle OpenGL pour le fonctionnement du processeur graphique: quels sont les blocs fonctionnels du GPU et
     à quoi servent-ils
##2 Principes de base de OpenGL: Représentation des données et des transformations géometriques: Matrices, vertex, lignes/triangles/..., projection et modèle de caméra
##3 Principes de base de OpenGL: Texture et système de coordonnées
##4 Principes de base de OpenGL: Modèle de lumière            
##5 Principes de base de OpenGL: Expliquez les différences entre DisplayList, VeretxArray et VertexBufferObject

##1 OpenGL Rendering Pipeline and the GPU

TODO par Pierre Lorin de Reure

##2 Principes de base de OpenGL: Représentation des données et des transformations géometriques: 
	Matrices, vertex, lignes/triangles/..., projection et modèle de caméra

== Les données de base OpenGL	
Les objets que OpenGl et le GPU savent bien traiter s'appellent les primitives (points, lignes et polygones). 
Elles crées à partir de sommets, dont on donne coordonnées spatiales entre les instructions glBegin() et glEnd().
La plupart des surfaces sont construites à partir de triangles. Ainsi l'approximation de surfaces courbées se fait grâce à une décomposition en triangles, 
dont qualité est définie par la subdivision.

L'intérêt d'OpenGL est de représenter ces primitives dans un espace 3D, 
de naviguer dans cet espace 3D et de choisir un point d'observation.
On peut alors, à l'aide de transformations matricielles, projeter ce qu'on voit depuis ce point d'observation sur un écran 2D. 

== Les transformations (produits matriciels)
#La transformation viewport
Permet d'indiquer sur quelle partie de la fenêtre on va occuper
glViewPort() 

#La transformation de projection (définit l'espace qui sera rendu)

Projection Perspective :
Analogie : choisir la lentille de la caméra
Spécifier la transformation qui rend les objets plus petits quand il sont loin, et borner l'espace qui sera rendu
glFrustum(-x1,x1,-y1,y1, distance au plan1, distance au plan2) 

Projection Orthonormale :
Analogie : Observation à l'infini
glOrtho(-x,x,-y,y-,z,z)

#Les transformations Viewing 
Analogie : positioner et viser avec la caméra
Faire un reset des transformations (matrice identité :) glLoadIdentity()
Choisir la translation de la caméra glTranslate[fdl]() et la rotation associée
OU utiliser la routine glu : gluLookAt() : spécifier la position de la caméra, un pt de référence, et le "haut" de la caméra

#Les transformations Modeling
Analogie : placer les éléments sur la scène
Positioner, orienter et scaler le modèle utilisé
On utilise les matrices de transformations entre glBegin() et glEnd()
On utilisera le stack des matrices glMatrixPush et glMatrixPop 

Note : Si l'on considère un repère absolu, considérer les transformations en ordre inverse

##3 Principes de base de OpenGL: Texture et système de coordonnées

#Texture de base
Une texture est un objet 2D que l'on va "plaquer" sur un objet 3D. 

On associe un repère à la texture :
Le système de coordonnées des textures est parfois appelé "UV coordinates". U et V sont compris entre 0 et 1.

Il faut préciser à OpenGL quelle partie de la texture on souhaite plaquer sur telle surface
Il suffira de donner pour chaque vertex, à quel niveau de la texture on se situe, et OpenGL fait le reste

#Mipmaps et filtres
//TODO
#Texture et shaders
//TODO

##4 Principes de base de OpenGL: Modèle de lumière
OpenGL raisonne sur des sources de lumières en RVB            
Division de l'éclairage en 4 : lumière  émissive, ambiante, diffuse, spéculaire

#Ambient illumination
Phénomène physique réel : réflection de la lumière sur les surfaces banales (murs, objects non réfléchissants, etc.)
Approximation OpenGL : impossible de déterminer l'origine des sources, donc on considère un niveau global de lumière dans l'espace
Elle est éparpillée dans toutes les directions

#Diffuse light
Phénomène physique réel : modèle facile utilisé par les télécom, réflection par les isolants
OpenGL : Lumière qui arrive d'une direction particulière, mais qui est réfléchie dans toutes les directions au contact d'un objet

#Specular light
Phénomène physique réel : exemple : effet de peau dans les métaux
OpenGL : Lumière qui arrive d'une direction particulière, et est renvoyée dans une autre direction particulière
C'est ce qu'on utilisera pour les points lumineux sur les objets

#Emissive color : 
Fonction de gain sur la lumière reçue et éclairement de base, sans augmenter la lumière renvoyée dans l'environnement.

#Affichage de la couleur
OpenGL gère l'absorption de fréquences via l'absorption de R, V et B de l'objet. La couleur affichée sera en taux de R,V, et B renvoyée par les objets.
Pour les flux lumineux/sources, (R,V,B) définissent l'intensité de la lumière (~quantité d'énergie, maximum = tous les pixels allumés, blanc)
Pour les objets, (R,V,B) définissent la partie réfléchie
Addition des couleurs renvoyées par chaque objet

#Rendering light :
Définir les vecteur normaux pour chaque surface (vers l'extérieur !)
Définir des sources
Choisir un modèle de lumière (lumière ambiante, etc.)
Définir les propriétés des matériaux


##5 Principes de base de OpenGL: Expliquez les différences entre DisplayList, VeretxArray et VertexBufferObject

#DisplayList

#VertexArray

#VertexBufferedObject
Permet de stocker des données de vertex dans la VRAM (mémoire GPU)
Permet un accès très rapide par le GPU et évite les échanges CPU <--> GPU qui sont souvent sources de lenteur

¤¤Création d'un VBO
¤Sous lwjgl, il faut recréer l'équivalent des GLint, GLfloat, etc...
	Créer un [Type]Buffer en spécifiant la taille ou un tableau déjà rempli (BufferUtils.create[TYPE]Buffer(SIZE || Float[]);
¤Réserver un buffer GPU (et récupérer son ID) à l'aide de glGenBuffersARB(buffer) (méthode de ARBVertexBufferObject)
	(renvoi d'un int id)				OU avec glGenBuffers(buffer) (méthode de GL15)
¤Choisir le buffer GPU actif à l'aide de l'ID généré si le GPU sait faire *
	GL15/ARB.glBindBuffer(GL15/ARB.GL_ARRAY_BUFFER, id); 
¤Envoyer les données dans le Buffer GPU (équivalent java : [Type]Buffer)
 ...En précisant l'utilisation des données et la fréquence de leur usage/modif**
	GL15/ARB.glBufferData(GL15/ARB.GL_ARRAY_BUFFER, buffer, GL15.GL_STATIC_DRAW);
	
**On peut demander si le GPU sait faire avec :
if(GLContext.getCapabilities().GL_ARB_vertex_buffer_object)	(équivalent GL15 aussi ?)
*	GL_(STATIC | STREAM | DYNAMIC)_(DRAW | READ | COPY). From the OpenGL docs:
STATIC - The data store contents will be modified once and used many times.
STREAM - The data store contents will be modified once and used at most a few times.
DYNAMIC - The data store contents will be modified repeatedly and used many times.
DRAW - The data store contents are modified by the application, and used as the source for GL drawing and image specification commands.
READ - The data store contents are modified by reading data from the GL, and used to return that data when queried by the application.
COPY - The data store contents are modified by reading data from the GL, and used as the source for GL drawing and image specification commands.

¤¤Utilisation d'un VBO (render)
¤Dire au client d'activer les vertexArray, colorArray, etc...
glEnableClientState(int param) param = GL_VERTEX_ARRAY, GL_COLOR_ARRAY, etc.
	Pour les Shaders, utiliser glEnableVertexAttribArray(int index)
¤Spécifier le type d'objet à rendre (Vertex, etc...) et sa position dans l'array
gl(Vertex|Color|Normal)Pointer(int size, int type, int stride, long offset)
	size = dimension (2,3,4), type = GL_[type], stride = distance entre 2 objets du même type (for interleawed arrays), offset = position du premier objet cherché
	Version shaders : glVertexAttribPointer(int index, int size, int type, boolean normalize, int stride, long offset)
¤Dire de tracer :
glVertexAttribPointer(int index, int size, int type, boolean normalize, int stride, long offset)
	pour les IBO : glDrawElements(int mode, int count, int type, long offset)
	(Il existe aussi d'autres fonctions : glDrawRangeElements, glMultiDrawArray, glMultiDrawElements